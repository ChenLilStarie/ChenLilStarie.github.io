
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>KRPC项目学习 - ChenLilStarie</title>

  
    <meta name="description" content="该项目自主实现了分布式环境下本地服务在RPC节点上的注册、发布与远程调用功能。主要实现了自定义通信协议、服务注册中心、日志系统及高并发网络模型，具备高性能和良好的扩展性。">
<meta property="og:type" content="article">
<meta property="og:title" content="KRPC项目学习">
<meta property="og:url" content="http://example.com/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/">
<meta property="og:site_name" content="ChenLilStarie">
<meta property="og:description" content="该项目自主实现了分布式环境下本地服务在RPC节点上的注册、发布与远程调用功能。主要实现了自定义通信协议、服务注册中心、日志系统及高并发网络模型，具备高性能和良好的扩展性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2025/08/26/pVy0fKg.jpg">
<meta property="article:published_time" content="2025-07-30T02:52:19.000Z">
<meta property="article:modified_time" content="2025-09-03T03:20:30.726Z">
<meta property="article:author" content="IrideChen">
<meta property="article:tag" content="KRPC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2025/08/26/pVy0fKg.jpg">
  
  
  
  <meta name="keywords" content="KRPC">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="https://s21.ax1x.com/2025/08/26/pVy0fKg.jpg">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"IrideChen","sameAs":[],"image":"https://s21.ax1x.com/2025/08/26/pVy0fKg.jpg"},"dateCreated":"2025-07-30T10:52:19+08:00","dateModified":"2025-09-03T11:20:30+08:00","datePublished":"2025-07-30T10:52:19+08:00","description":"该项目自主实现了分布式环境下本地服务在RPC节点上的注册、发布与远程调用功能。主要实现了自定义通信协议、服务注册中心、日志系统及高并发网络模型，具备高性能和良好的扩展性。","headline":"KRPC项目学习","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},"publisher":{"@type":"Organization","name":"IrideChen","sameAs":[],"image":"https://s21.ax1x.com/2025/08/26/pVy0fKg.jpg","logo":{"@type":"ImageObject","url":"https://s21.ax1x.com/2025/08/26/pVy0fKg.jpg"}},"url":"http://example.com/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/","keywords":"KRPC","image":[]}</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/xaoxuu/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/xaoxuu/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/xaoxuu/favicon/favicon-16x16.png"><link rel="manifest" href="/assets/xaoxuu/favicon/site.webmanifest"><link rel="shortcut icon" href="/assets/xaoxuu/favicon/favicon.ico"><meta name="theme-color" content="#f8f8f8"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" media="all" />
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://s21.ax1x.com/2025/08/26/pVy0fKg.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">ChenLilStarie</div><div class="sub normal cap">醉后不知天在水</div><div class="sub hover cap" style="opacity:0"> 满船清梦压星河</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item active" title="专栏" href="/topic/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于" href="/about/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a><a class="nav-item" title="碎碎念" href="/Memos/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>

<widget class="widget-wrapper markdown"><div class="widget-header dis-select"><span class="name">Welcome to ChenLilStarie's Space</span></div><div class="widget-body fs14"><p>流光容易，客人暂歇，祝好！</p>

<div class="linklist center" style="grid-template-columns:repeat(1,1fr);">
<a class="link" title="关于我" href="/about/"><div class="flex"><span>关于我</span></div></a></div></div></widget>

<widget class="widget-wrapper related post-list"><div class="widget-header dis-select"><span class="name">专栏：C/Cpp项目学习</span></div><div class="widget-body"><a class="item active" href="/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"><span class="title">KRPC项目学习</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a></div></widget>

<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/09/04/select%E3%80%81poll%E5%92%8Cepoll/"><span class="title">select、poll和epoll</span></a><a class="item title" href="/2025/09/04/map%E4%B8%8Eunordered-map%E5%85%B3%E9%94%AE%E5%AD%97/"><span class="title">map与unordered_map关键字</span></a><a class="item title" href="/2025/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="title">设计模式</span></a><a class="item title" href="/2025/09/02/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"><span class="title">volatile关键字</span></a><a class="item title" href="/2025/09/03/const%E5%85%B3%E9%94%AE%E5%AD%97/"><span class="title">const关键字</span></a><a class="item title" href="/2025/09/01/Cpp%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/"><span class="title">Cpp虚函数相关</span></a><a class="item title" href="/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"><span class="title">KRPC项目学习</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/ChenLilStarie/" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="https://music.163.com/#/user/home?id=413300885" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic/">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/">C/Cpp项目学习</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-07-30T02:52:19.000Z">2025-07-30</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-09-03T03:20:30.726Z">2025-09-03</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>KRPC项目学习</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>该项目自主实现了分布式环境下本地服务在RPC节点上的注册、发布与远程调用功能。主要实现了自定义通信协议、服务注册中心、日志系统及高并发网络模型，具备高性能和良好的扩展性。</p>
<span id="more"></span>

<p>RPC介绍：是远程过程调用的缩写，可以通过网络从远程服务器上请求服务。具体功能简要来讲就是用户可以像在本地调用函数一样在客户端从服务器远程调用函数。</p>
<p>以下为需要的前置知识学习，不需要的可以跳过此部分：</p>
<h1 id="ZooKeeper概述"><a href="#ZooKeeper概述" class="headerlink" title="ZooKeeper概述"></a>ZooKeeper概述</h1><p>概念：一个分布式的开源的分布式应用程序的协调服务。</p>
<p>功能：1.配置管理2.分布式锁3.集群管理。</p>
<ol>
<li>配置管理：对于多个程序，设置一个配置中心，将配置信息写入配置中心中，当需要相应的配置信息时，直接从配置中心拉取对应的配置信息。</li>
<li>分布式锁：</li>
</ol>
<ul>
<li>单机：当一个用户访问数据时，为其加锁，当该用户访问完后解锁，其他用户才能进入并访问。</li>
<li>多用户：设置一个分布式锁的组件，当其中一个事务上锁时，另外一个事务需等待锁释放后才能上锁。</li>
</ul>
<ol start="3">
<li>集群管理：设置注册1中心，provider将地址提供给注册中心，当consumer需要访问provider时，先从注册中心获取provider的地址，然后访问provider。</li>
</ol>
<p>（本项目仅用到了zookeeper的api配置，所以只了解到这里）</p>
<h1 id="TCP-IP协议的工作原理："><a href="#TCP-IP协议的工作原理：" class="headerlink" title="TCP&#x2F;IP协议的工作原理："></a>TCP&#x2F;IP协议的工作原理：</h1><p>它是一个协议簇，包含四个协议：</p>
<p>应用协议：主要包括HTTP协议（超文本传输协议），SMTP协议（简单邮件传送协议），FTP（文件传输协议）等</p>
<p>传输层协议：TCP（传输控制协议），UDP（用户数据报协议）</p>
<p>网际互联协议：IP, ARP, RARP, ICMP</p>
<p>路由控制协议</p>
<h2 id="（一）TCP协议的核心特性"><a href="#（一）TCP协议的核心特性" class="headerlink" title="（一）TCP协议的核心特性"></a>（一）TCP协议的核心特性</h2><ol>
<li>面向连接：在数据传输前先建立连接，传输完成后释放连接。</li>
<li>可靠性：通过序列号、确认应答、超时重传机制确保数据准确到达。</li>
<li>字节流传输：数据被视为连续的字节流，没有消息边界的概念。</li>
<li>全双工通信：运行通信双方同时进行数据传输。</li>
<li>流量控制：通过滑窗机制控制数据发送速率，防止接收双方缓冲区溢出。</li>
<li>拥塞控制：动态调整数据发送速率，避免网络拥塞。</li>
</ol>
<h2 id="（二）三次握手概念"><a href="#（二）三次握手概念" class="headerlink" title="（二）三次握手概念"></a>（二）三次握手概念</h2><p>第一步：客户发送SYN包：客户端向服务器发送一个TCP数据包，SYN（同步序列号）标志位被设为1，表示这是一个连接请求包。同时客户端随机选择一个初始序列号（ISN），假设为x，将其放入数据包的序列号字段中，客户端发送SYN包后进入SYN_SENT阶段，等待服务器的响应。</p>
<p>第二步：服务器发送SYN-ACK包：服务器接到客户端的SYN包后，会为该连接分配必要的资源，服务器将SYN与ACK标志位都设置为1，表示同意建立连接并对客户端的请求进行确认。服务器也会随机选择一个初始序列号，假设为y，放入数据包的序列号字段中，同时将确认号字段设置为x+1，表示已收到客户端的SYN包，期待接下来收到客户端序列号为x+1的数据包，服务器发送SYN-ACK包后进入SYN-RCYD状态。</p>
<p>第三步：客户端发送ACK包：客户端接收到服务器发送的SYN-ACK包后，会检查确认号是否为x+1，如果是，则认为服务器已正确接受到自己的SYN包，客户端将ACK标志位设置为1，序列号字段设置为x+1，确认号字段设置为y+1，表示已收到服务器的SYN包，期望接下来收到服务器序列号为y+1的数据包。客户端发送ACK包后进入ESTABLISHED状态，此时客户端可以开始向服务器发送数据。</p>
<p>服务器接收到ACK包后，也进入ESTABLISHED状态，双方连接建立成功。</p>
<p>三次握手的设计原理：1.客户端发送SYN确保客户端有发送数据的能力。第二次握手证明服务器具有接收和发送数据的能力。第三次握手证明客户端可以接收数据。</p>
<ol start="2">
<li>TCP协议通过同步初始序列号来跟踪每个字节的传输速度，并且初始序列号是随机生成的，降低被预测攻击的风险。</li>
<li>防止历史连接的干扰，服务器在接受到SYN时会发送SYN-ACK包，而当客户端接受到SYN-ACK包时会根据确认号是否正确才会发送最后的ACK包。</li>
</ol>
<h2 id="（三）TCP优化："><a href="#（三）TCP优化：" class="headerlink" title="（三）TCP优化："></a>（三）TCP优化：</h2><p>TFO技术：在SYN报文中携带数据，减少一次RTT（往返时间）延迟。</p>
<p>SYN cookie：一种应对SYN flood攻击的技术。SYN flood攻击：攻击者伪造大量的SYN包，耗尽服务器资源，导致正常请求无法处理。SYN cookie技术在SYN-ACK包中嵌入</p>
<h2 id="（四）TCP报文"><a href="#（四）TCP报文" class="headerlink" title="（四）TCP报文"></a>（四）TCP报文</h2><p>里面有几个关键字段：</p>
<ol>
<li>序号：标识本报文段在发送方字节流中的位置。</li>
<li>确认号：表示接受方期望接收的下一个字节的序号。如果接收到了序号为x的字节，那么它会返回确认号x+1，确认号只有在ACK标志位为1的报文中有效。</li>
<li>控制位。包含八个标志位，用于控制 TCP 的各种操作。其中，CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；ECE若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；ACK 标志位表示确认号是否有效；SYN 标志位用于建立连接；FIN 标志位用于关闭连接；RST 标志位用于重置连接；PSH 标志位提示接收方应尽快将数据传递给应用层；URG 标志位表示紧急指针是否有效。</li>
</ol>
<h2 id="（五）TCP的数据分段与重组"><a href="#（五）TCP的数据分段与重组" class="headerlink" title="（五）TCP的数据分段与重组"></a>（五）TCP的数据分段与重组</h2><p>每个网络链路都有一个最大传输单元（NTU），表示该链路能传输的最大数据包大小。TCP在发送数据时，会根据网络的MTU来决定每个段的大小，以避免数据在网络层被分片。TCP通常在三次握手过程中协商最大段大小（MSS）来确定每个段的最大数据量。MSS通常等于MTU减去IP头和TCP头的长度。</p>
<h2 id="（六）可靠传输"><a href="#（六）可靠传输" class="headerlink" title="（六）可靠传输"></a>（六）可靠传输</h2><ol>
<li>ACK延迟：接收方在接收多个报文后发送一个ACK报文，或者有数据要发送时将ACK与数据一同发送，提高传输效率。</li>
<li>PSH标志：接收方在收到有PSH标志的报文时会立刻将缓冲区的数据传递给应用层，不用等待缓冲区满。</li>
<li>超时重传：设置超时时间，当一段时间内发送方没有接到反馈的ACK包就会重新发送该数据段。TCP超时时间一般由RTT（数据往返时间）确定。</li>
<li>最大重传次数：当超过一定重传次数后依然没有收到ACK包，发送方则认为接收端出现了问题，则会关闭连接。</li>
<li>快速重传，当接收方收到失序的段时，会发送重复的ACK包，这样发送方就会得知接收方期望序列的数据包没有发送，从而立即重传该段。</li>
<li>序列号的作用：1。数据排序。2数据去重。3确认应答。</li>
<li>数据去重的判断步骤：检查接收到的数据的序列号，若该数据在接收窗口内并且还没被接收，则将其放入缓冲区。以下情况将被丢弃：（1）已被确认接收的数据（2）如果该序列号大于接收窗口的上界，则将其丢弃。</li>
</ol>
<h2 id="（七）滑动窗口与流量限制"><a href="#（七）滑动窗口与流量限制" class="headerlink" title="（七）滑动窗口与流量限制"></a>（七）滑动窗口与流量限制</h2><ol>
<li>发送方滑窗设置：已发送并确认，已发送未确认，未发送但可发送，未发送不可发送。</li>
<li>接收方滑窗：表示可以接收的数据量，由接收方剩余缓冲区空间决定。</li>
<li>缩放因子：当窗口大小不足以充分利用网络带宽时，接收方通告一个缩放因子n，那么发送方在接收到这个缩放因子后发送的实际窗口大小则为2^n*窗口大小个字节。</li>
</ol>
<h2 id="（八）拥塞控制机制（四个阶段）"><a href="#（八）拥塞控制机制（四个阶段）" class="headerlink" title="（八）拥塞控制机制（四个阶段）"></a>（八）拥塞控制机制（四个阶段）</h2><ol>
<li>慢启动：连接建立初期，拥塞窗口初始化为一个最大段大小，每收到一个ACK报文拥塞窗口就增加一个MSS的大小；或者每收到一轮的ACK报文，拥塞窗口就翻倍。公式如下：</li>
</ol>
<p>$ cwnd&#x3D;cwnd+MSS $</p>
<p>$ Cwnd&#x3D;cwnd*2 $</p>
<ol start="2">
<li>慢启动阈值：当拥塞窗口增长到慢启动阈值时，结束慢启动阶段，进入拥塞避免阶段。</li>
<li>拥塞避免阶段：拥塞窗口进入线性增长状态。</li>
</ol>
<p>$ cwnd&#x3D;cwnd+(MSS*MSS)&#x2F;cwnd $4.拥塞判断：（1）超时事件（将拥塞窗口减半，并且重置为一个MSS）（2）发送方接收到三个重复的ACK报文（执行快速重传和快速回复）</p>
<p> 5.快速重传：前面已经说过。</p>
<p> 6.快速恢复：将慢启动阈值设置为当前拥塞窗口一半，将拥塞窗口设置为慢启动阈值加上3倍的MSS，随后执行拥塞避免算法。</p>
<h2 id="（九）四次挥手"><a href="#（九）四次挥手" class="headerlink" title="（九）四次挥手"></a>（九）四次挥手</h2><p>1，主动关闭方发送FIN包：FIN标志位设为1，序列号字段设为u，进入FIN_WAIT_1状态</p>
<p>2.被动关闭方发送ACK包，ACK标志位设为1，序列号字段设为v，确认号字段设为u+1，等待确认，进入CLOSE_WAIT状态，此时被动关闭方依然可以向主动关闭方发送数据</p>
<p>3.被动关闭方发送FIN包：被动关闭方传输完数据后，向主动关闭方发送一个FIN包，标志位设为1，序列号字段为v，确认号字段设为u+1，随后进入LAST_ACK状态。</p>
<p>4.主动关闭方发送ACK包，标志位为1，序列号字段为u+1，确认号字段为v+1，，进入TIME_WAIT阶段，等待一段时间（2倍的最大段生存期2MSL）</p>
<p>被动关闭方收到ACK包后进入CLOSED状态，主动关闭方等待一段时间后也进入CLOSED状态。</p>
<h2 id="（十）TCP与UDP区别"><a href="#（十）TCP与UDP区别" class="headerlink" title="（十）TCP与UDP区别"></a>（十）TCP与UDP区别</h2><p>TCP面向连接， 可靠传输，字节流，UDP无连接，不可靠传输，数据报</p>
<p>TCP效率较UDP低，消耗资源较高。</p>
<h1 id="IO模型："><a href="#IO模型：" class="headerlink" title="IO模型："></a>IO模型：</h1><ol>
<li>阻塞型IO：在操作系统完成IO操作前，会中断其他事务的操作，操作简单，适用于并发量小的开发。</li>
<li>非阻塞型IO：在操作系统完成IO操作前依然可以进行其他事务的操作，但是会使用轮询或事件机制两种机制去确认该IO操作是否完成：1.轮询就是时常询问该IO是否完成，会占用CPU时间2.事件机制就是IO完成后发送中断完成信号。非阻塞IO适用于高并发场景。</li>
<li>同步型IO：必须等待IO操作完成后才能执行后续代码。（要点：阻塞型IO一定是同步型IO，但是同步型IO不一定是阻塞型IO，比如使用休眠机制等待IO完成）</li>
<li>异步IO：程序发起IO操作后立即返回，内核负责完成所有操作，完成后通知应用程序。适用于极高并发需求的场景。</li>
<li>多路复用：允许单个线程通过一个系统调用监视多个文件描述符，当其中任何一个描述符就绪时，系统调用返回。下面讲select，poll以及epoll机制。</li>
</ol>
<h2 id="（一）多路复用的三种机制："><a href="#（一）多路复用的三种机制：" class="headerlink" title="（一）多路复用的三种机制："></a>（一）多路复用的三种机制：</h2><p>Select：初始化fd_set集合，调用select并等待，随后select遍历所有fd检查就绪状态，然后处理就绪的fd。</p>
<p>Poll：初始化pollfd数组，调用poll并等待，poll返回后遍历pollfd数组检查revents，返回就绪的fd。</p>
<p>Epoll：创建epoll实例，使用epoll_ctl添加修改删除监视的fd，调用epoll_wait等待事件，处理返回的就绪事件。</p>
<p>以下是三种机制的区别：</p>
<ol>
<li><strong>性能和效率</strong>：<ul>
<li><strong>Select</strong>：在处理大量文件描述符时性能较差，因为每次调用都需要遍历所有文件描述符，且文件描述符数量受限（通常为1024）。</li>
<li><strong>Poll</strong>：性能较Select有所提升，因为Poll支持更大的文件描述符数量（无上限），但仍然需要遍历所有文件描述符。</li>
<li><strong>Epoll</strong>：性能最优，尤其是处理大量文件描述符时。Epoll采用事件驱动机制，只处理就绪的文件描述符，避免了遍历所有文件描述符的开销。</li>
</ul>
</li>
<li><strong>文件描述符数量</strong>：<ul>
<li><strong>Select</strong>：文件描述符数量有限制（通常为1024）。</li>
<li><strong>Poll</strong>：文件描述符数量无上限。</li>
<li><strong>Epoll</strong>：文件描述符数量无上限，适合处理大量连接。</li>
</ul>
</li>
<li><strong>阻塞和唤醒机制</strong>：<ul>
<li><strong>Select</strong>：阻塞在select调用，直到有文件描述符就绪。</li>
<li><strong>Poll</strong>：阻塞在poll调用，直到有文件描述符就绪。</li>
<li><strong>Epoll</strong>：阻塞在epoll_wait调用，直到有注册的事件发生。Epoll还支持边缘触发（Edge-Triggered）和水平触发（Level-Triggered）模式，进一步优化性能。</li>
</ul>
</li>
<li><strong>内存使用</strong>：<ul>
<li><strong>Select</strong>：需要维护一个fd_set集合，内存使用较高。</li>
<li><strong>Poll</strong>：需要维护一个pollfd数组，内存使用较高。</li>
<li><strong>Epoll</strong>：内存使用较低，因为Epoll只处理就绪的文件描述符。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>Select</strong>：适用于小规模应用，文件描述符数量较少。</li>
<li><strong>Poll</strong>：适用于中等规模应用，文件描述符数量较多但不极端。</li>
<li><strong>Epoll</strong>：适用于大规模应用，特别是需要处理大量并发连接的场景（如高并发服务器）。</li>
</ul>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><strong>Select</strong>：简单易用，但性能较差，适用于小型应用。</li>
<li><strong>Poll</strong>：性能较Select有所提升，适用于中型应用。</li>
<li><strong>Epoll</strong>：性能最优，适用于大规模高并发场景，是Linux环境下处理大量文件描述符的最佳选择。</li>
</ul>
<h1 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h1><h2 id="（一）请求响应步骤："><a href="#（一）请求响应步骤：" class="headerlink" title="（一）请求响应步骤："></a>（一）请求响应步骤：</h2><ol>
<li>客户端与服务器HTTP端口建立TCP套接字连接。</li>
<li>发送HTTP请求：通过TCP套接字客户端向服务器发送一个文本的请求报文，一个请求报文由请求行，请求头部，空行与请求数据四部分组成。</li>
<li>服务器接受请求并返回HTTP响应：服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行与响应数据四部分组成。</li>
<li>释放TCP连接：两个状态：close状态，服务器主动关闭连接，客户端被动关闭连接。Keepalive状态，连接会保持一段时间，在时间内可以继续接受请求。</li>
<li>客户端浏览器解析HTML内容：首先解析状态行，查看表明请求是否成功的状态代码。随后解析响应头，响应头告知HTML文档，随后读取响应数据HTML并对其格式化并显示。</li>
</ol>
<h2 id="（二）无连接"><a href="#（二）无连接" class="headerlink" title="（二）无连接"></a>（二）无连接</h2><p>服务器处理完客户请求并收到客户应答后即断开连接。但是HTTP1.1对其进行了优化，在处理完客户请求后，会等待几秒后再关闭连接，这几秒等待的作用是在客户还有后续请求时可以复用该连接，提高效率。</p>
<h2 id="（三）请求方法（区分大小写，这部分需要注意）"><a href="#（三）请求方法（区分大小写，这部分需要注意）" class="headerlink" title="（三）请求方法（区分大小写，这部分需要注意）"></a>（三）请求方法（区分大小写，这部分需要注意）</h2><ol>
<li>GET：向指定的资源发出“显示”请求。</li>
<li>HEAD：与GET方法一样，向服务器发出指定资源的请求。不过服务器不传回资源的本文部分。</li>
<li>POST：向指定资源提交数据，请求服务器进行处理。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源。</li>
<li>PUT：向指定资源位置上传其最新内容。</li>
<li>DELETE：请求服务器删除request-url所标识的资源。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
<li>OPTIONS：使服务器传回该资源所支持的所有HTTP请求方法，用‘*’代替资源名称向web服务器发送OPTION请求，可以测试该服务器功能是否正常运作。</li>
<li>CONNECT：HTTP1.1协议中预留给能将连接改为管道方式的代理服务器，通常用于SSL加密服务器的链接。</li>
</ol>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>服务器不支持对应请求时会发送405，不认识对应请求时会发送501。</li>
<li>GET与HEAD方法是必须实现的，其他方法可选。</li>
<li>GET提交的数据会放在URL之后，也就是请求行里面，用？分割URL与传输数据，参数之间以&amp;相连。</li>
<li>GET提交的数据大小有限制，而POST提交的数据没有限制</li>
</ol>
<h2 id="（四）状态码"><a href="#（四）状态码" class="headerlink" title="（四）状态码"></a>（四）状态码</h2><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p>
<p>状态代码的第一个数组代表当前响应的类型。</p>
<h2 id="（五）URL"><a href="#（五）URL" class="headerlink" title="（五）URL"></a>（五）URL</h2><p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p>
<ul>
<li><p>传送协议。 层级URL标记符号(为[&#x2F;&#x2F;],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址）</p>
</li>
<li><p>端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略） 路径。（以“&#x2F;”字符区别路径中的每一个目录名称）</p>
</li>
<li><p>查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“&#x3D;”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）</p>
</li>
<li><p>片段。以“#”字符为起点</p>
</li>
</ul>
<p>以 <a target="_blank" rel="noopener" href="http://www.luffycity.com/news/index.html?id=250&page=1">http://www.luffycity.com:80/news/index.html?id=250&amp;page=1</a> 为例, 其中：</p>
<ul>
<li>http，是协议；</li>
<li><a target="_blank" rel="noopener" href="http://www.luffycity.com,是服务器;/">http://www.luffycity.com，是服务器；</a></li>
<li>80，是服务器上的默认网络端口号，默认不显示；</li>
<li>&#x2F;news&#x2F;index.html，是路径（URI：直接定位到对应的资源）；</li>
<li>?id&#x3D;250&amp;page&#x3D;1，是查询。</li>
</ul>
<p>大多数网页浏览器不要求用户输入网页中“http:&#x2F;&#x2F;”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分就可以了。</p>
<p>由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务。</p>
<h1 id="数据序列化与反序列化"><a href="#数据序列化与反序列化" class="headerlink" title="数据序列化与反序列化"></a>数据序列化与反序列化</h1><p>由于项目主要使用的是Proto3，这里针对Proto3进行学习。主要信息来源：<a target="_blank" rel="noopener" href="https://protobuf.com.cn/programming-guides/proto3/">Proto官方指南</a></p>
<h2 id="（一）定义消息类型"><a href="#（一）定义消息类型" class="headerlink" title="（一）定义消息类型"></a>（一）定义消息类型</h2><p>如果要用proto3来编写，syntax&#x3D;”proto3”；必须是文件的第一个非空、非注释行，如果没有指定则默认proto2。</p>
<p>message 消息名{}：花括号内定义字段的名称与类型</p>
<p>例：string name&#x3D;1;这里1是编号，name是名称，string是类型。</p>
<h2 id="（二）指定字段类型"><a href="#（二）指定字段类型" class="headerlink" title="（二）指定字段类型"></a>（二）指定字段类型</h2><p>字段类型除了标量类型还有枚举及其他消息类型等复合类型。</p>
<h2 id="（三）分配字段编号"><a href="#（三）分配字段编号" class="headerlink" title="（三）分配字段编号"></a>（三）分配字段编号</h2><ol>
<li>给定编号在该消息的所有字段中必须唯一。</li>
<li>字段编号1900到1999保留用于Protocol Buffers实现。</li>
<li>不能使用任何以前保留的字段编号，也不能使用分配给扩展的任何字段编号。</li>
<li>消息类型一旦投入使用，编号不能更改</li>
<li>字段编号不能被重用。</li>
<li>常设置的字段编号应设置在1-15之间，1-15占用1个字节，16到2047占用2个字节。</li>
</ol>
<h2 id="（四）指定字段基数"><a href="#（四）指定字段基数" class="headerlink" title="（四）指定字段基数"></a>（四）指定字段基数</h2><ol>
<li>Singular：推荐使用optional类型的单一字段，它具有两种可能的状态：1.字段已设置，它将会被序列化到线格式中。2.字段未设置，将返回默认值，不会被序列化到线格式中。</li>
<li>repeated：该字段类型在格式良好的信息中可以重复零次或多次。重复值的顺序将得到保留。在proto3中，标量数值类型的repeated字段默认使用packed编码。</li>
<li>Map：这是一种成对的键&#x2F;值字段类型。</li>
</ol>
<h2 id="（五）格式良好的消息"><a href="#（五）格式良好的消息" class="headerlink" title="（五）格式良好的消息"></a>（五）格式良好的消息</h2><p>单一字段可以在线格式字节中出现多次。解析器接受输入，但只有该字段的最后一个实例可以通过生成的绑定访问。</p>
<h2 id="（六）更多消息类型"><a href="#（六）更多消息类型" class="headerlink" title="（六）更多消息类型"></a>（六）更多消息类型</h2><p>单个.proto文件中可以定义多个消息类型，但是当大量具有不同依赖关系的消息定义在同一个文件中时，这也会导致依赖膨胀。</p>
<h2 id="（七）删除字段"><a href="#（七）删除字段" class="headerlink" title="（七）删除字段"></a>（七）删除字段</h2><p>当需要在客户端代码中删除所有引用时，必须保留已删除的字段编号，否则开发者会很有可能重用该编号，并且应该保留字段名称，以便JSON编码与TextFormant编码能继续解析。将保留的字段编号与字段名称写入reserved列表中，一个reserved语句中不能混合使用字段名称与字段编号。</p>
<h2 id="（八）文件生成"><a href="#（八）文件生成" class="headerlink" title="（八）文件生成"></a>（八）文件生成</h2><p>对于C++，每个.proto文件会生成一个.h文件和.cc文件，文件中描述的每种消息类型都会有一个对应的类。</p>
<h2 id="（九）标量值类型"><a href="#（九）标量值类型" class="headerlink" title="（九）标量值类型"></a>（九）标量值类型</h2><p>类型较多，详情请见官方文档。</p>
<h2 id="（十）默认字段值"><a href="#（十）默认字段值" class="headerlink" title="（十）默认字段值"></a>（十）默认字段值</h2><ol>
<li>对于字符串，默认值为空字符串</li>
<li>对于bytes，默认值为空bytes</li>
<li>对于bools，默认值为false</li>
<li>对于数值类型默认值为0</li>
<li>对于枚举，默认值是定义的第一个枚举值，该值必须为0</li>
<li>重复字段默认值为空</li>
<li>map字段默认值为空。</li>
</ol>
<p>消息类型到此为止，以下为服务定义部分：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">CalculatorService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">rpc</span> Add (AddRequest) <span class="keyword">returns</span> (AddResponse)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">rpc</span> Subtract (SubtractRequest) <span class="keyword">returns</span> (SubtractResponse)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个服务定义的示例，里面一行的内容：</p>
<p>Add、SubStract：远程方法名</p>
<p>AddRequest、SubtractRequest：输入参数类型，必须是消息类型</p>
<p>AddResponse、SubtractResponse：返回参数类型，必须是消息类型</p>
<p>Proto3的基础使用语法部分到此为止，后续为C++侧需要实现的部分。</p>
<h1 id="Muduo网络库："><a href="#Muduo网络库：" class="headerlink" title="Muduo网络库："></a>Muduo网络库：</h1><p>这部分作者陈硕出了一本书叫《Linux多线程服务端编程》，建议直接找书吃透，可以淘宝上买也可以在网上找到电子书资源。</p>
<h1 id="代码正式学习（这里主要提出来设计细节）："><a href="#代码正式学习（这里主要提出来设计细节）：" class="headerlink" title="代码正式学习（这里主要提出来设计细节）："></a>代码正式学习（这里主要提出来设计细节）：</h1><h2 id="user-proto"><a href="#user-proto" class="headerlink" title="user.proto:"></a>user.proto:</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;<span class="comment">//使用proto3语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Kuser;<span class="comment">//命名空间为Kuser</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services=<span class="literal">true</span>;<span class="comment">//生成C++服务接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode=<span class="number">1</span>;<span class="comment">//错误码</span></span><br><span class="line">    <span class="type">bytes</span> errmsg=<span class="number">2</span>;<span class="comment">//错误信息，C++中对应std::string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name=<span class="number">1</span>;<span class="comment">//用户名</span></span><br><span class="line">    <span class="type">bytes</span> pwd=<span class="number">2</span>;<span class="comment">//密码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result=<span class="number">1</span>;<span class="comment">//操作结果</span></span><br><span class="line">    <span class="type">bool</span> success=<span class="number">2</span>;<span class="comment">//登录是否成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> id=<span class="number">1</span>;<span class="comment">//用户id</span></span><br><span class="line">    <span class="type">bytes</span> name=<span class="number">2</span>;<span class="comment">//用户名</span></span><br><span class="line">    <span class="type">bytes</span> pwd=<span class="number">3</span>;<span class="comment">//密码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterResponse</span>&#123;</span><br><span class="line">    ResultCode result=<span class="number">1</span>;<span class="comment">//操作结果</span></span><br><span class="line">    <span class="type">bool</span> success=<span class="number">2</span>;<span class="comment">//注册是否成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;<span class="comment">//服务接口定义</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Register(RegisterRequest) <span class="keyword">returns</span>(RegisterResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计要点：</p>
<ol>
<li>错误处理标准化：resultcode作为统一错误返回结构，所有响应均包含操作结果与操作状态</li>
<li>服务扩展性：新增RPC方法只需在service中添加新rpc定义，新字段向后兼容。</li>
<li>跨语言：proto文件可生成Java&#x2F;Python等客户端。</li>
</ol>
<h2 id="Krpcheader-proto"><a href="#Krpcheader-proto" class="headerlink" title="Krpcheader.proto:"></a>Krpcheader.proto:</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Krpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RpcHeader</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> service_name=<span class="number">1</span>;<span class="comment">//服务名</span></span><br><span class="line">    <span class="type">bytes</span> method_name=<span class="number">2</span>;<span class="comment">//方法名</span></span><br><span class="line">    <span class="type">uint32</span> args_size=<span class="number">3</span>;<span class="comment">//参数数据长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Krpcconfig（配置加载模块）"><a href="#Krpcconfig（配置加载模块）" class="headerlink" title="Krpcconfig（配置加载模块）:"></a>Krpcconfig（配置加载模块）:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">pf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    fopen(config_file, <span class="string">&quot;r&quot;</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">    &amp;fclose</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 如果文件打开失败</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用unique_ptr确保文件在任何情况下都会关闭，自定义删除器&amp;fclose保证资源安全</p>
<p>配置解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];  <span class="comment">// 用于存储从文件中读取的每一行内容</span></span><br><span class="line">    <span class="comment">// 使用pf.get()方法获取原始指针，逐行读取文件内容</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="number">1024</span>, pf.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;  <span class="comment">// 将读取的内容转换为字符串</span></span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);  <span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略注释行（以#开头）和空行</span></span><br><span class="line">        <span class="keyword">if</span> (read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || read_buf.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找键值对的分隔符&#x27;=&#x27;</span></span><br><span class="line">        <span class="type">int</span> index = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="keyword">continue</span>;  <span class="comment">// 如果没有找到&#x27;=&#x27;，跳过该行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取键（key）</span></span><br><span class="line">        std::string key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">        <span class="built_in">Trim</span>(key);  <span class="comment">// 去掉key前后的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找行尾的换行符</span></span><br><span class="line">        <span class="type">int</span> endindex = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, index);</span><br><span class="line">        <span class="comment">// 提取值（value），并去掉换行符</span></span><br><span class="line">        std::string value = read_buf.<span class="built_in">substr</span>(index + <span class="number">1</span>, endindex - index - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);  <span class="comment">// 去掉value前后的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将键值对存入配置map中</span></span><br><span class="line">        config_map.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据key值查找对应的value：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据key查找对应的value</span></span><br><span class="line"><span class="function">std::string <span class="title">Krpcconfig::Load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = config_map.<span class="built_in">find</span>(key);  <span class="comment">// 在map中查找key</span></span><br><span class="line">    <span class="keyword">if</span> (it == config_map.<span class="built_in">end</span>()) &#123;  <span class="comment">// 如果未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;  <span class="comment">// 返回对应的value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Krpcconfig::Trim</span><span class="params">(std::string &amp;read_buf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">    <span class="type">int</span> index = read_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;  <span class="comment">// 如果找到非空格字符</span></span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(index, read_buf.<span class="built_in">size</span>() - index);  <span class="comment">// 截取字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉字符串后面的空格</span></span><br><span class="line">    index = read_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;  <span class="comment">// 如果找到非空格字符</span></span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, index + <span class="number">1</span>);  <span class="comment">// 截取字符串</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用find_first_not_of与find_last_not_of除去空格，避免不必要的内存拷贝。</p>
<h3 id="可优化点："><a href="#可优化点：" class="headerlink" title="可优化点："></a>可优化点：</h3><ol>
<li>支持更多数据类型</li>
<li>添加热更新支持</li>
<li>支持多级配置</li>
</ol>
<h2 id="Krpclogger（日志系统）："><a href="#Krpclogger（日志系统）：" class="headerlink" title="Krpclogger（日志系统）："></a>Krpclogger（日志系统）：</h2><p>RALL资源管理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">KrpcLogger</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *argv0)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        google::<span class="built_in">InitGoogleLogging</span>(argv0);</span><br><span class="line">        FLAGS_colorlogtostderr=<span class="literal">true</span>;<span class="comment">//启用彩色日志</span></span><br><span class="line">        FLAGS_logtostderr=<span class="literal">true</span>;<span class="comment">//默认输出标准错误</span></span><br><span class="line">      &#125;</span><br><span class="line">      ~<span class="built_in">KrpcLogger</span>()&#123;</span><br><span class="line">        google::<span class="built_in">ShutdownGoogleLogging</span>();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>构造函数初始化Glog系统，禁用拷贝构造与赋值保证单例性。</p>
<p>日志接口设计：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供静态日志方法</span></span><br><span class="line">      <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO)&lt;&lt;message;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Warning</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span></span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING)&lt;&lt;message;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ERROR</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span></span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR)&lt;&lt;message;</span><br><span class="line">      &#125;</span><br><span class="line">          <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Fatal</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; message;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>禁用拷贝构造函数与赋值重载函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//禁用拷贝构造函数和重载赋值函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">KrpcLogger</span>(<span class="type">const</span> KrpcLogger&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    KrpcLogger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> KrpcLogger&amp;)=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h3 id="可优化点：-1"><a href="#可优化点：-1" class="headerlink" title="可优化点："></a>可优化点：</h3><ol>
<li>增加文件输出</li>
<li>支持日志分级控制</li>
<li>添加日志轮转</li>
</ol>
<h2 id="Krpcapplication（框架入口与系统管理）："><a href="#Krpcapplication（框架入口与系统管理）：" class="headerlink" title="Krpcapplication（框架入口与系统管理）："></a>Krpcapplication（框架入口与系统管理）：</h2><p>全局配置对象与互斥锁准备：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Krpcconfig KrpcApplication::m_config;  <span class="comment">// 全局配置对象</span></span><br><span class="line">std::mutex KrpcApplication::m_mutex;  <span class="comment">// 用于线程安全的互斥锁</span></span><br><span class="line">KrpcApplication* KrpcApplication::m_application = <span class="literal">nullptr</span>;  <span class="comment">// 单例对象指针，初始为空</span></span><br></pre></td></tr></table></figure>

<p>创建单例对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">KrpcApplication &amp;<span class="title">KrpcApplication::GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;  <span class="comment">// 加锁，保证线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (m_application == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 如果单例对象还未创建</span></span><br><span class="line">        m_application = <span class="keyword">new</span> <span class="built_in">KrpcApplication</span>();  <span class="comment">// 创建单例对象</span></span><br><span class="line">        <span class="built_in">atexit</span>(deleteInstance);  <span class="comment">// 注册atexit函数，程序退出时自动销毁单例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *m_application;  <span class="comment">// 返回单例对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁保证线程安全，atexit确保资源释放。</p>
<p>命令行参数解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化函数，用于解析命令行参数并加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;  <span class="comment">// 如果命令行参数少于2个，说明没有指定配置文件</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;格式: command -i &lt;配置文件路径&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  <span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> o;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="comment">// 使用getopt解析命令行参数，-i表示指定配置文件</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != (o = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:  <span class="comment">// 如果参数是-i，后面的值就是配置文件的路径</span></span><br><span class="line">                config_file = optarg;  <span class="comment">// 将配置文件路径保存到config_file</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:  <span class="comment">// 如果出现未知参数（不是-i），提示正确格式并退出</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;格式: command -i &lt;配置文件路径&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:  <span class="comment">// 如果-i后面没有跟参数，提示正确格式并退出</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;格式: command -i &lt;配置文件路径&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安全的资源管理：加载失败后会终止程序，与退出自动释放一同保证了资源不泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">KrpcApplication</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">KrpcApplication</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">KrpcApplication</span>(<span class="type">const</span> KrpcApplication&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">KrpcApplication</span>(KrpcApplication&amp;&amp;)=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>禁用了所有构造方式，保证了严格的单例控制。</p>
<h3 id="可优化点：-2"><a href="#可优化点：-2" class="headerlink" title="可优化点："></a>可优化点：</h3><ol>
<li>增强配置验证</li>
<li>支持动态重载</li>
</ol>
<h2 id="KrpcChannel："><a href="#KrpcChannel：" class="headerlink" title="KrpcChannel："></a>KrpcChannel：</h2><p>该部分负责实现protobuf的rpcchannel接口。</p>
<h3 id="RPC头部组装："><a href="#RPC头部组装：" class="headerlink" title="RPC头部组装："></a>RPC头部组装：</h3><p>组装过程结合KrpcHeader来理解：设置service_name&#x2F;method_name，计算参数序列化长度args_size。序列化rpcheader，写入头部长度，拼接头部+参数。</p>
<p>该部分作用：</p>
<ol>
<li>标识这是RPC请求而非普通数据包。</li>
<li>指明调用的服务和方法。</li>
<li>校验数据，确保参数完整传输。</li>
</ol>
<p>该部分包含的模块：</p>
<ol>
<li>初始化客户端socket：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == m_clientfd) &#123;  <span class="comment">// 如果客户端socket未初始化</span></span><br><span class="line">        <span class="comment">// 获取服务对象名和方法名</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::ServiceDescriptor *sd = method-&gt;<span class="built_in">service</span>();</span><br><span class="line">        service_name = sd-&gt;<span class="built_in">name</span>();  <span class="comment">// 服务名</span></span><br><span class="line">        method_name = method-&gt;<span class="built_in">name</span>();  <span class="comment">// 方法名</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>找到服务器地址：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端需要查询ZooKeeper，找到提供该服务的服务器地址</span></span><br><span class="line">        ZkClient zkCli;</span><br><span class="line">        zkCli.<span class="built_in">Start</span>();  <span class="comment">// 连接ZooKeeper服务器</span></span><br><span class="line">        std::string host_data = <span class="built_in">QueryServiceHost</span>(&amp;zkCli, service_name, method_name, m_idx);  <span class="comment">// 查询服务地址</span></span><br><span class="line">        m_ip = host_data.<span class="built_in">substr</span>(<span class="number">0</span>, m_idx);  <span class="comment">// 从查询结果中提取IP地址</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ip: &quot;</span> &lt;&lt; m_ip &lt;&lt; std::endl;</span><br><span class="line">        m_port = <span class="built_in">atoi</span>(host_data.<span class="built_in">substr</span>(m_idx + <span class="number">1</span>, host_data.<span class="built_in">size</span>() - m_idx).<span class="built_in">c_str</span>());  <span class="comment">// 从查询结果中提取端口号</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;port: &quot;</span> &lt;&lt; m_port &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>连接服务器：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试连接服务器</span></span><br><span class="line">        <span class="keyword">auto</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">        <span class="keyword">if</span> (!rt) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;connect server error&quot;</span>;  <span class="comment">// 连接失败，记录错误日志</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;connect server success&quot;</span>;  <span class="comment">// 连接成功，记录日志</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>序列化请求参数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将请求参数序列化为字符串，并计算其长度</span></span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line">    std::string args_str;</span><br><span class="line">    <span class="keyword">if</span> (request-&gt;<span class="built_in">SerializeToString</span>(&amp;args_str)) &#123;  <span class="comment">// 序列化请求参数</span></span><br><span class="line">        args_size = args_str.<span class="built_in">size</span>();  <span class="comment">// 获取序列化后的长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize request fail&quot;</span>);  <span class="comment">// 序列化失败，设置错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>定义请求头部信息：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义RPC请求的头部信息</span></span><br><span class="line">    Krpc::RpcHeader krpcheader;</span><br><span class="line">    krpcheader.<span class="built_in">set_service_name</span>(service_name);  <span class="comment">// 设置服务名</span></span><br><span class="line">    krpcheader.<span class="built_in">set_method_name</span>(method_name);  <span class="comment">// 设置方法名</span></span><br><span class="line">    krpcheader.<span class="built_in">set_args_size</span>(args_size);  <span class="comment">// 设置参数长度</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>序列化头部信息并计算长度：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将RPC头部信息序列化为字符串，并计算其长度</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="keyword">if</span> (krpcheader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str)) &#123;  <span class="comment">// 序列化头部信息</span></span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();  <span class="comment">// 获取序列化后的长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize rpc header error!&quot;</span>);  <span class="comment">// 序列化失败，设置错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>拼接RPC请求报文：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::string send_rpc_str;</span><br><span class="line">    &#123;</span><br><span class="line">        google::protobuf::<span class="function">io::StringOutputStream <span class="title">string_output</span><span class="params">(&amp;send_rpc_str)</span></span>;</span><br><span class="line">        google::protobuf::<span class="function">io::CodedOutputStream <span class="title">coded_output</span><span class="params">(&amp;string_output)</span></span>;</span><br><span class="line">        coded_output.<span class="built_in">WriteVarint32</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header_size));  <span class="comment">// 写入头部长度</span></span><br><span class="line">        coded_output.<span class="built_in">WriteString</span>(rpc_header_str);  <span class="comment">// 写入头部信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    send_rpc_str += args_str;  <span class="comment">// 拼接请求参数</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>发送请求到服务器：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送RPC请求到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">send</span>(m_clientfd, send_rpc_str.<span class="built_in">c_str</span>(), send_rpc_str.<span class="built_in">size</span>(), <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 发送失败，关闭socket</span></span><br><span class="line">        <span class="type">char</span> errtxt[<span class="number">512</span>] = &#123;&#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;send error: &quot;</span> &lt;&lt; <span class="built_in">strerror_r</span>(errno, errtxt, <span class="built_in">sizeof</span>(errtxt)) &lt;&lt; std::endl;  <span class="comment">// 打印错误信息</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);  <span class="comment">// 设置错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里及后续代码为什么仅明显的写出了错误处理：在执行if判断的同时就会执行发送请求，等待响应，反序列化等操作，如果成功，则不会执行if内的语句，这体现了UNIX网络编程的典型模式“失败即异常，成功即默认”。</p>
<p>IO模型：阻塞</p>
<ol start="9">
<li>接收服务器响应：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收服务器的响应</span></span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (recv_size = <span class="built_in">recv</span>(m_clientfd, recv_buf, <span class="number">1024</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="type">char</span> errtxt[<span class="number">512</span>] = &#123;&#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;recv error&quot;</span> &lt;&lt; <span class="built_in">strerror_r</span>(errno, errtxt, <span class="built_in">sizeof</span>(errtxt)) &lt;&lt; std::endl;  <span class="comment">// 打印错误信息</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);  <span class="comment">// 设置错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>!! 粘包处理：通过长度前缀明确消息边界。</p>
<ol start="10">
<li>反序列化：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将接收到的响应数据反序列化为response对象</span></span><br><span class="line">    <span class="keyword">if</span> (!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size)) &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 反序列化失败，关闭socket</span></span><br><span class="line">        <span class="type">char</span> errtxt[<span class="number">512</span>] = &#123;&#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;parse error&quot;</span> &lt;&lt; <span class="built_in">strerror_r</span>(errno, errtxt, <span class="built_in">sizeof</span>(errtxt)) &lt;&lt; std::endl;  <span class="comment">// 打印错误信息</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);  <span class="comment">// 设置错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>创建新的socket连接：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KrpcChannel::newConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">uint16_t</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) &#123;</span><br><span class="line">        <span class="type">char</span> errtxt[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; <span class="built_in">strerror_r</span>(errno, errtxt, <span class="built_in">sizeof</span>(errtxt)) &lt;&lt; std::endl;  <span class="comment">// 打印错误信息</span></span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;socket error:&quot;</span> &lt;&lt; errtxt;  <span class="comment">// 记录错误日志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;  <span class="comment">// IPv4地址族</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 端口号</span></span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);  <span class="comment">// IP地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr))) &#123;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);  <span class="comment">// 连接失败，关闭socket</span></span><br><span class="line">        <span class="type">char</span> errtxt[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; <span class="built_in">strerror_r</span>(errno, errtxt, <span class="built_in">sizeof</span>(errtxt)) &lt;&lt; std::endl;  <span class="comment">// 打印错误信息</span></span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;connect server error&quot;</span> &lt;&lt; errtxt;  <span class="comment">// 记录错误日志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_clientfd = clientfd;  <span class="comment">// 保存socket文件描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端发现："><a href="#客户端发现：" class="headerlink" title="客户端发现："></a>客户端发现：</h3><p>节点注册规范：</p>
<p>服务端注册路径：&#x2F;$ {service_name}&#x2F; ${method_name}</p>
<p>节点数据格式：IP:Port</p>
<p>临时节点：利用ZooKeeper的临时节点特性实现服务下线自动清除</p>
<ol>
<li>加分布式锁获取数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">KrpcChannel::QueryServiceHost</span><span class="params">(ZkClient *zkclient, std::string service_name, std::string method_name, <span class="type">int</span> &amp;idx)</span> </span>&#123;</span><br><span class="line">    std::string method_path = <span class="string">&quot;/&quot;</span> + service_name + <span class="string">&quot;/&quot;</span> + method_name;  <span class="comment">// 构造ZooKeeper路径</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_path: &quot;</span> &lt;&lt; method_path &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_data_mutx)</span></span>;  <span class="comment">// 加锁，保证线程安全</span></span><br><span class="line">    std::string host_data_1 = zkclient-&gt;<span class="built_in">GetData</span>(method_path.<span class="built_in">c_str</span>());  <span class="comment">// 从ZooKeeper获取数据</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>错误处理：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (host_data_1 == <span class="string">&quot;&quot;</span>) &#123;  <span class="comment">// 如果未找到服务地址</span></span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; method_path + <span class="string">&quot; is not exist!&quot;</span>;  <span class="comment">// 记录错误日志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idx = host_data_<span class="number">1.f</span>ind(<span class="string">&quot;:&quot;</span>);  <span class="comment">// 查找IP和端口的分隔符</span></span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">-1</span>) &#123;  <span class="comment">// 如果分隔符不存在</span></span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; method_path + <span class="string">&quot; address is invalid!&quot;</span>;  <span class="comment">// 记录错误日志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> host_data_1;  <span class="comment">// 返回服务地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>延迟连接：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，支持延迟连接</span></span><br><span class="line">KrpcChannel::<span class="built_in">KrpcChannel</span>(<span class="type">bool</span> connectNow) : <span class="built_in">m_clientfd</span>(<span class="number">-1</span>), <span class="built_in">m_idx</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!connectNow) &#123;  <span class="comment">// 如果不需要立即连接</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接服务器，最多重试3次</span></span><br><span class="line">    <span class="keyword">auto</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;  <span class="comment">// 重试次数</span></span><br><span class="line">    <span class="keyword">while</span> (!rt &amp;&amp; count--) &#123;</span><br><span class="line">        rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询失败时会进行重试，此处重试次数设为3次。</p>
<h3 id="可优化点：-3"><a href="#可优化点：-3" class="headerlink" title="可优化点："></a>可优化点：</h3><ol>
<li>增加连接池管理</li>
<li>添加超时控制</li>
</ol>
<h2 id="Krpcprovider"><a href="#Krpcprovider" class="headerlink" title="Krpcprovider:"></a>Krpcprovider:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h3 id="NotifyService函数："><a href="#NotifyService函数：" class="headerlink" title="NotifyService函数："></a>NotifyService函数：</h3><p>功能：将Protobuf生成的服务类注册到RPC框架</p>
<p>调用：在Run()之前调用</p>
<p>服务描述符获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过动态多态调用 service-&gt;GetDescriptor()，</span></span><br><span class="line">    <span class="comment">// GetDescriptor() 方法会返回 protobuf 生成的服务类的描述信息（ServiceDescriptor）。</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *psd = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br></pre></td></tr></table></figure>

<p>通过protobuf反射机制获取服务的元信息。</p>
<p>ServiceDsecipter包含服务名，方法列表，各方法的输入输出类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务的名字</span></span><br><span class="line">   std::string service_name = psd-&gt;<span class="built_in">name</span>();</span><br><span class="line">   <span class="comment">// 获取服务端对象service的方法数量</span></span><br><span class="line">   <span class="type">int</span> method_count = psd-&gt;<span class="built_in">method_count</span>();</span><br></pre></td></tr></table></figure>

<p>获取服务名及方法数量。</p>
<p>方法遍历注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历服务中的所有方法，并注册到服务信息中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; method_count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取服务中的方法描述</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmd = psd-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmd-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name=&quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">        service_info.method_map.<span class="built_in">emplace</span>(method_name, pmd);  <span class="comment">// 将方法名和方法描述符存入map</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>服务信息存储：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> service_info.service = service;  <span class="comment">// 保存服务对象</span></span><br><span class="line">    service_map.<span class="built_in">emplace</span>(service_name, service_info);  <span class="comment">// 将服务信息存入服务map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立服务名-&gt;方法名-&gt;方法实现的二级映射。</p>
<p>设计细节：</p>
<ol>
<li>利用Protobuf原生反射API，避免手动维护服务列表。</li>
<li>标准化接口：所有服务统一通过google：：protobuf：：Service基类操作。</li>
<li>在服务启动前完成方法存在性检查。</li>
</ol>
<h3 id="Run函数："><a href="#Run函数：" class="headerlink" title="Run函数："></a>Run函数：</h3><p>函数功能：</p>
<ol>
<li>启动RPC服务端网络监听</li>
<li>注册服务到ZooKeeper</li>
<li>进入事件循环</li>
</ol>
<p>配置读取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件中的RPC服务器IP和端口</span></span><br><span class="line">    std::string ip = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用muduo网络库，创建地址对象</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br></pre></td></tr></table></figure>

<p>依赖Krpcapplication部分从全局配置读取IP&#x2F;端口。</p>
<p>网络服务初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;muduo::net::TcpServer&gt; server = std::<span class="built_in">make_shared</span>&lt;muduo::net::TcpServer&gt;(&amp;event_loop, address, <span class="string">&quot;KrpcProvider&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定连接回调和消息回调，分离网络连接业务和消息处理业务</span></span><br><span class="line">    server-&gt;<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server-&gt;<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置muduo库的线程数量</span></span><br><span class="line">    server-&gt;<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>使用shared_ptr管理TCP服务对象生命周期</p>
<p>shared_ptr优势：</p>
<ol>
<li>多线程环境中自动引用计数保证生命周期。</li>
<li>异步回调场景中通过shared_from_this延长生命周期。</li>
<li>异常安全场景中RALL自动释放。</li>
</ol>
<p>回调绑定分离连接处理与消息处理。</p>
<p>ZooKeeper服务注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前RPC节点上要发布的服务全部注册到ZooKeeper上，让RPC客户端可以在ZooKeeper上发现服务</span></span><br><span class="line">    ZkClient zkclient;</span><br><span class="line">    zkclient.<span class="built_in">Start</span>();  <span class="comment">// 连接ZooKeeper服务器</span></span><br><span class="line">    <span class="comment">// service_name为永久节点，method_name为临时节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;sp : service_map) &#123;</span><br><span class="line">        <span class="comment">// service_name 在ZooKeeper中的目录是&quot;/&quot;+service_name</span></span><br><span class="line">        std::string service_path = <span class="string">&quot;/&quot;</span> + sp.first;</span><br><span class="line">        zkclient.<span class="built_in">Create</span>(service_path.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>);  <span class="comment">// 创建服务节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;mp : sp.second.method_map) &#123;</span><br><span class="line">            std::string method_path = service_path + <span class="string">&quot;/&quot;</span> + mp.first;</span><br><span class="line">            <span class="type">char</span> method_path_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">sprintf</span>(method_path_data, <span class="string">&quot;%s:%d&quot;</span>, ip.<span class="built_in">c_str</span>(), port);  <span class="comment">// 将IP和端口信息存入节点数据</span></span><br><span class="line">            <span class="comment">// ZOO_EPHEMERAL表示这个节点是临时节点，在客户端断开连接后，ZooKeeper会自动删除这个节点</span></span><br><span class="line">            zkclient.<span class="built_in">Create</span>(method_path.<span class="built_in">c_str</span>(), method_path_data, <span class="built_in">strlen</span>(method_path_data), ZOO_EPHEMERAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里服务名称节点为永久节点，而方法节点为临时节点，随服务进程退出自动删除。</p>
<p>事件循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server-&gt;<span class="built_in">start</span>();</span><br><span class="line">    event_loop.<span class="built_in">loop</span>();  <span class="comment">// 进入事件循环</span></span><br></pre></td></tr></table></figure>

<p>start()立即返回，为非阻塞启动服务。loop()进入事件循环。</p>
<h3 id="OnMessage-函数："><a href="#OnMessage-函数：" class="headerlink" title="OnMessage()函数："></a>OnMessage()函数：</h3><p>函数功能：</p>
<ol>
<li>解析RPC请求报文。</li>
<li>路由到对应的服务方法。</li>
<li>动态调用并返回响应。</li>
</ol>
<p>数据接收与初步处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();<span class="comment">//清空缓冲区并获取数据。</span></span><br></pre></td></tr></table></figure>

<p>协议头解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用protobuf的CodedInputStream反序列化RPC请求</span></span><br><span class="line">    google::protobuf::<span class="function">io::ArrayInputStream <span class="title">raw_input</span><span class="params">(recv_buf.data(), recv_buf.size())</span></span>;</span><br><span class="line">    google::protobuf::<span class="function">io::CodedInputStream <span class="title">coded_input</span><span class="params">(&amp;raw_input)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> header_size&#123;&#125;;</span><br><span class="line">    coded_input.<span class="built_in">ReadVarint32</span>(&amp;header_size);  <span class="comment">// 解析header_size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到RPC请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    Krpc::RpcHeader krpcHeader;</span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置读取限制</span></span><br><span class="line">    google::protobuf::io::CodedInputStream::Limit msg_limit = coded_input.<span class="built_in">PushLimit</span>(header_size);</span><br><span class="line">    coded_input.<span class="built_in">ReadString</span>(&amp;rpc_header_str, header_size);</span><br><span class="line">    <span class="comment">// 恢复之前的限制，以便安全地继续读取其他数据</span></span><br><span class="line">    coded_input.<span class="built_in">PopLimit</span>(msg_limit);</span><br></pre></td></tr></table></figure>

<p>结构：接收数据 $\rightarrow$ varint32头部长度 $\rightarrow$ 头部数据 $\rightarrow$ 业务参数</p>
<p>安全设置：PushLimit确保不会读取超过header_size的数据，防止恶意构造的超大长度导致OOM。</p>
<p>服务方法路由：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = service_map.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="keyword">if</span> (it == service_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mit = it-&gt;second.method_map.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span> (mit == it-&gt;second.method_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::Service *service = it-&gt;second.service;  <span class="comment">// 获取服务对象</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second;  <span class="comment">// 获取方法对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过service_name查找服务对象，通过method_name查找方法描述符。</p>
<p>动态调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">google::protobuf::Service *service = it-&gt;second.service;  <span class="comment">// 获取服务对象</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second;  <span class="comment">// 获取方法对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成RPC方法调用请求的request和响应的response参数</span></span><br><span class="line">    google::protobuf::Message *request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();  <span class="comment">// 动态创建请求对象</span></span><br><span class="line">    <span class="keyword">if</span> (!request-&gt;<span class="built_in">ParseFromString</span>(args_str)) &#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message *response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();  <span class="comment">// 动态创建响应对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定回调函数，用于在方法调用完成后发送响应</span></span><br><span class="line">    google::protobuf::Closure *done = google::protobuf::<span class="built_in">NewCallback</span>&lt;KrpcProvider,</span><br><span class="line">                                                                    <span class="type">const</span> muduo::net::TcpConnectionPtr &amp;,</span><br><span class="line">                                                                    google::protobuf::Message *&gt;(<span class="keyword">this</span>,</span><br><span class="line">                                                                                                 &amp;KrpcProvider::SendRpcResponse,</span><br><span class="line">                                                                                                 conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在框架上根据远端RPC请求，调用当前RPC节点上发布的方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);  <span class="comment">// 调用服务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>GetRequestPrototype动态创建参数对象</p>
</li>
<li><p>CallMethod通过方法描述符触发实际调用</p>
</li>
<li><p>使用NewCallback()确保响应发送时对象存活。</p>
</li>
</ol>
<p>松耦合设计保证业务逻辑与网络层完全隔离。</p>
<h3 id="SendRpcResponse-函数："><a href="#SendRpcResponse-函数：" class="headerlink" title="SendRpcResponse()函数："></a>SendRpcResponse()函数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送RPC响应给客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, google::protobuf::Message *response)</span> </span>&#123;</span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span> (response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str)) &#123;</span><br><span class="line">        <span class="comment">// 序列化成功，通过网络把RPC方法执行的结果返回给RPC调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;serialize error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// conn-&gt;shutdown(); // 模拟HTTP短链接，由RpcProvider主动断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数功能：将RPC调用的结果序列化并发送回客户端。</p>
<p>调用时机：在服务方法执行完成后，通过Protobuf的Closure机制触发。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>conn</code></td>
<td align="left"><code>muduo::net::TcpConnectionPtr</code></td>
<td align="left">代表客户端连接的智能指针</td>
</tr>
<tr>
<td align="left"><code>response</code></td>
<td align="left"><code>google::protobuf::Message*</code></td>
<td align="left">动态生成的响应消息对象</td>
</tr>
</tbody></table>
<h3 id="可优化点：-4"><a href="#可优化点：-4" class="headerlink" title="可优化点："></a>可优化点：</h3><ol>
<li>使用writev合并头部与参数的发送。</li>
<li>双缓冲：预分配内存避免频繁申请释放。</li>
<li>批量发送</li>
</ol>
<h2 id="zookeeperutil"><a href="#zookeeperutil" class="headerlink" title="zookeeperutil:"></a>zookeeperutil:</h2><p>函数功能：</p>
<ol>
<li>将RPC服务节点信息写入ZooKeeper</li>
<li>查询可用服务节点地址</li>
<li>维护与ZooKeeper集群的会话</li>
</ol>
<p>global_watcher函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">global_watcher</span><span class="params">(<span class="type">zhandle_t</span> *zh, <span class="type">int</span> type, <span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">void</span> *watcherCtx)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zh</code></td>
<td align="left"><code>zhandle_t*</code></td>
<td align="left">ZooKeeper客户端句柄，标识触发事件的连接</td>
</tr>
<tr>
<td align="left"><code>type</code></td>
<td align="left"><code>int</code></td>
<td align="left">事件类型（如会话事件、节点变更事件等）</td>
</tr>
<tr>
<td align="left"><code>status</code></td>
<td align="left"><code>int</code></td>
<td align="left">事件状态（如连接成功、认证失败等）</td>
</tr>
<tr>
<td align="left"><code>path</code></td>
<td align="left"><code>const char*</code></td>
<td align="left">触发事件的节点路径（对会话事件为NULL）</td>
</tr>
<tr>
<td align="left"><code>watcherCtx</code></td>
<td align="left"><code>void*</code></td>
<td align="left">用户自定义上下文，初始化时通过<code>zookeeper_init</code>传入</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">global_watcher</span><span class="params">(<span class="type">zhandle_t</span> *zh, <span class="type">int</span> type, <span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">void</span> *watcherCtx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == ZOO_SESSION_EVENT) &#123;  <span class="comment">// 回调消息类型和会话相关的事件</span></span><br><span class="line">        <span class="keyword">if</span> (status == ZOO_CONNECTED_STATE) &#123;  <span class="comment">// ZooKeeper客户端和服务器连接成功</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;  <span class="comment">// 加锁保护</span></span><br><span class="line">            is_connected = <span class="literal">true</span>;  <span class="comment">// 标记连接成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>仅关注连接成功事件，忽略其他事件。</li>
<li>通过互斥锁保护is_connected标志。</li>
<li>使用条件变量实现异步回调转同步等待。</li>
</ol>
<p>与ZooKeeper客户端的关系</p>
<ol>
<li>每个zhandle_t实例只能有一个全局watcher。</li>
<li>生命周期与客户端句柄绑定，在zookeeper_close时失效。</li>
</ol>
<h3 id="Start函数："><a href="#Start函数：" class="headerlink" title="Start函数："></a>Start函数：</h3><p>函数功能：主要完成ZooKeeper客户端连接建立和会话管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中读取ZooKeeper服务器的IP和端口</span></span><br><span class="line">   std::string host = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperip&quot;</span>);</span><br><span class="line">   std::string port = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperport&quot;</span>);</span><br><span class="line">   std::string connstr = host + <span class="string">&quot;:&quot;</span> + port;  <span class="comment">// 拼接连接字符串</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   zookeeper_mt：多线程版本</span></span><br><span class="line"><span class="comment">   ZooKeeper的API客户端程序提供了三个线程：</span></span><br><span class="line"><span class="comment">   1. API调用线程</span></span><br><span class="line"><span class="comment">   2. 网络I/O线程（使用pthread_create和poll）</span></span><br><span class="line"><span class="comment">   3. watcher回调线程（使用pthread_create）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用zookeeper_init初始化一个ZooKeeper客户端对象，异步建立与服务器的连接</span></span><br><span class="line">   m_zhandle = <span class="built_in">zookeeper_init</span>(connstr.<span class="built_in">c_str</span>(), global_watcher, <span class="number">6000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_zhandle) &#123;  <span class="comment">// 初始化失败</span></span><br><span class="line">       <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;zookeeper_init error&quot;</span>;</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_FAILURE);  <span class="comment">// 退出程序</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 等待连接成功</span></span><br><span class="line">   <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;</span><br><span class="line">   cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> is_connected; &#125;);  <span class="comment">// 阻塞等待，直到连接成功</span></span><br><span class="line">   <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;zookeeper_init success&quot;</span>;  <span class="comment">// 记录日志，表示连接成功</span></span><br></pre></td></tr></table></figure>

<p>这里注释写的比较全面，不过多解释。</p>
<p>关键设计：</p>
<ol>
<li>异步转同步机制。</li>
<li>多线程安全实现：<ol>
<li>is_connected变量通过mutex保护。</li>
<li>cv.wait()保证仅在连接成功后继续执行。</li>
</ol>
</li>
</ol>
<h3 id="Create函数："><a href="#Create函数：" class="headerlink" title="Create函数："></a>Create函数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ZooKeeper节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZkClient::Create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> datalen, <span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> path_buffer[<span class="number">128</span>];  <span class="comment">// 用于存储创建的节点路径</span></span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(path_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查节点是否已经存在</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_exists</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == ZNONODE) &#123;  <span class="comment">// 如果节点不存在</span></span><br><span class="line">        <span class="comment">// 创建指定的ZooKeeper节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, state, path_buffer, bufferlen);</span><br><span class="line">        <span class="keyword">if</span> (flag == ZOK) &#123;  <span class="comment">// 创建成功</span></span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;znode create success... path:&quot;</span> &lt;&lt; path;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 创建失败</span></span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;znode create failed... path:&quot;</span> &lt;&lt; path;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);  <span class="comment">// 退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分要点：</p>
<ol>
<li>zoo_exists是同步阻塞调用</li>
<li>服务注册使用ZOO_EPHEMERAL，客户端断开自动清除。</li>
</ol>
<h3 id="GetData函数："><a href="#GetData函数：" class="headerlink" title="GetData函数："></a>GetData函数：</h3><p>函数功能：从ZooKeeper节点读取数据，实现服务发现能力。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];  <span class="comment">// 用于存储节点数据</span></span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定节点的数据</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_get</span>(m_zhandle, path, <span class="number">0</span>, buf, &amp;bufferlen, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag != ZOK) &#123;  <span class="comment">// 获取失败</span></span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;zoo_get error&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 返回空字符串</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 获取成功</span></span><br><span class="line">        <span class="keyword">return</span> buf;  <span class="comment">// 返回节点数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 默认返回空字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可优化点：-5"><a href="#可优化点：-5" class="headerlink" title="可优化点："></a>可优化点：</h3><ol>
<li>为service_map加锁，保证多线程注册服务不冲突</li>
<li>检查service指针的有效性</li>
<li>对象池复用</li>
<li>零拷贝分析</li>
<li>异步日志队列</li>
</ol>
<h2 id="KrpcControler："><a href="#KrpcControler：" class="headerlink" title="KrpcControler："></a>KrpcControler：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，初始化控制器状态</span></span><br><span class="line">Krpccontroller::<span class="built_in">Krpccontroller</span>() &#123;</span><br><span class="line">    m_failed = <span class="literal">false</span>;  <span class="comment">// 初始状态为未失败</span></span><br><span class="line">    m_errText = <span class="string">&quot;&quot;</span>;    <span class="comment">// 错误信息初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置控制器状态，将失败标志和错误信息清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Krpccontroller::Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_failed = <span class="literal">false</span>;  <span class="comment">// 重置失败标志</span></span><br><span class="line">    m_errText = <span class="string">&quot;&quot;</span>;    <span class="comment">// 清空错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前RPC调用是否失败</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Krpccontroller::Failed</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_failed;  <span class="comment">// 返回失败标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取错误信息</span></span><br><span class="line"><span class="function">std::string <span class="title">Krpccontroller::ErrorText</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_errText;  <span class="comment">// 返回错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置RPC调用失败，并记录失败原因</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Krpccontroller::SetFailed</span><span class="params">(<span class="type">const</span> std::string &amp;reason)</span> </span>&#123;</span><br><span class="line">    m_failed = <span class="literal">true</span>;   <span class="comment">// 设置失败标志</span></span><br><span class="line">    m_errText = reason; <span class="comment">// 记录失败原因</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="项目设计思路与结构总结："><a href="#项目设计思路与结构总结：" class="headerlink" title="项目设计思路与结构总结："></a>项目设计思路与结构总结：</h1><h2 id="分层架构："><a href="#分层架构：" class="headerlink" title="分层架构："></a>分层架构：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|     业务逻辑层        | (用户定义的Service实现)</span><br><span class="line">+-----------------------+</span><br><span class="line">|     RPC框架层        | (KrpcProvider/KrpcChannel)</span><br><span class="line">+-----------------------+</span><br><span class="line">|  网络通信与序列化层   | (Muduo + Protobuf)</span><br><span class="line">+-----------------------+</span><br><span class="line">|   服务发现与协调层    | (ZooKeeper)</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>

<h2 id="核心组件交互："><a href="#核心组件交互：" class="headerlink" title="核心组件交互："></a>核心组件交互：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Client端:</span><br><span class="line">[业务调用] → [KrpcChannel] → [序列化] → [网络传输] → [ZooKeeper服务发现]</span><br><span class="line">                                                      ↑</span><br><span class="line">Server端:                                             ↓</span><br><span class="line">[网络接收] → [反序列化] → [KrpcProvider] → [业务实现] ← [ZooKeeper服务注册]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">类名</th>
<th align="left">主要职责</th>
</tr>
</thead>
<tbody><tr>
<td align="left">KrpcApplication</td>
<td align="left">框架入口，配置管理，单例模式保证全局访问</td>
</tr>
<tr>
<td align="left">KrpcProvider</td>
<td align="left">服务端核心，注册服务，处理RPC请求路由</td>
</tr>
<tr>
<td align="left">KrpcChannel</td>
<td align="left">客户端核心，管理连接，序列化请求，发送RPC调用</td>
</tr>
<tr>
<td align="left">ZkClient</td>
<td align="left">ZooKeeper客户端封装，处理服务注册与发现</td>
</tr>
<tr>
<td align="left">KrpcController</td>
<td align="left">RPC调用控制，错误处理</td>
</tr>
<tr>
<td align="left">Krpcconfig</td>
<td align="left">配置文件解析，支持key-value格式配置</td>
</tr>
<tr>
<td align="left">KrpcLogger</td>
<td align="left">基于Glog的日志系统，提供不同级别日志接口</td>
</tr>
</tbody></table>
<h2 id="关键流程设计"><a href="#关键流程设计" class="headerlink" title="关键流程设计"></a>关键流程设计</h2><h3 id="1-服务启动流程"><a href="#1-服务启动流程" class="headerlink" title="1. 服务启动流程"></a>1. 服务启动流程</h3><ol>
<li>加载配置(IP&#x2F;Port&#x2F;ZK地址等)</li>
<li>注册服务到ServiceMap</li>
<li>连接ZooKeeper集群</li>
<li>将服务方法注册为ZK节点</li>
<li>启动Muduo网络服务</li>
</ol>
<h3 id="2-RPC调用流程"><a href="#2-RPC调用流程" class="headerlink" title="2. RPC调用流程"></a>2. RPC调用流程</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端:"></a><strong>客户端</strong>:</h4><ol>
<li>通过ZK查询服务地址</li>
<li>建立TCP连接</li>
<li>序列化请求(header+args)</li>
<li>发送请求并等待响应</li>
<li>反序列化响应</li>
</ol>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端:"></a><strong>服务端</strong>:</h4><ol>
<li>接收并解析请求头</li>
<li>从ServiceMap查找对应服务方法</li>
<li>反序列化请求参数</li>
<li>通过CallMethod动态调用</li>
<li>序列化响应并返回</li>
</ol>
<h3 id="3-错误处理流程"><a href="#3-错误处理流程" class="headerlink" title="3. 错误处理流程"></a>3. 错误处理流程</h3><ul>
<li>通过KrpcController记录错误状态</li>
<li>错误类型包括：<ul>
<li>序列化&#x2F;反序列化失败</li>
<li>服务&#x2F;方法不存在</li>
<li>网络通信错误</li>
<li>ZooKeeper操作失败</li>
</ul>
</li>
</ul>
</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    


    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="http://example.com/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=http://example.com/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/&title=KRPC项目学习 - ChenLilStarie&summary=该项目自主实现了分布式环境下本地服务在RPC节点上的注册、发布与远程调用功能。主要实现了自定义通信协议、服务注册中心、日志系统及高并发网络模型，具备高性能和良好的扩展性。"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=KRPC项目学习 - ChenLilStarie&amp;body=http://example.com/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://example.com/2025/07/30/KRPC%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
        </div>
        
      </div>
    </section>
    </div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/09/01/Cpp%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/">Cpp虚函数相关</a></div><div class="item" id="next"></div></section></div>






<footer class="page-footer footnote"><hr><div class="sitemap" style="column-count:2;"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">关于</span><a href="/about/">我</a></div></div><div class="text"><p>本站由 <a href="/">IrideChen</a> 于2023年1月，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。<br>本站由 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/">腾讯云</a> 提供CDN加速。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ZooKeeper%E6%A6%82%E8%BF%B0"><span class="toc-text">ZooKeeper概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">TCP&#x2F;IP协议的工作原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">（一）TCP协议的核心特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%A6%82%E5%BF%B5"><span class="toc-text">（二）三次握手概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89TCP%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-text">（三）TCP优化：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89TCP%E6%8A%A5%E6%96%87"><span class="toc-text">（四）TCP报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89TCP%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%AE%B5%E4%B8%8E%E9%87%8D%E7%BB%84"><span class="toc-text">（五）TCP的数据分段与重组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">（六）可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%B5%81%E9%87%8F%E9%99%90%E5%88%B6"><span class="toc-text">（七）滑动窗口与流量限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-text">（八）拥塞控制机制（四个阶段）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B9%9D%EF%BC%89%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">（九）四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%EF%BC%89TCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB"><span class="toc-text">（十）TCP与UDP区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">IO模型：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">（一）多路复用的三种机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-text">HTTP协议：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">（一）请求响应步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="toc-text">（二）无连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%88%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%8C%E8%BF%99%E9%83%A8%E5%88%86%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%89"><span class="toc-text">（三）请求方法（区分大小写，这部分需要注意）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-text">注意：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">（四）状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89URL"><span class="toc-text">（五）URL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">数据序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">（一）定义消息类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-text">（二）指定字段类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E9%85%8D%E5%AD%97%E6%AE%B5%E7%BC%96%E5%8F%B7"><span class="toc-text">（三）分配字段编号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%9F%BA%E6%95%B0"><span class="toc-text">（四）指定字段基数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E6%A0%BC%E5%BC%8F%E8%89%AF%E5%A5%BD%E7%9A%84%E6%B6%88%E6%81%AF"><span class="toc-text">（五）格式良好的消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E6%9B%B4%E5%A4%9A%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">（六）更多消息类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5"><span class="toc-text">（七）删除字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90"><span class="toc-text">（八）文件生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B9%9D%EF%BC%89%E6%A0%87%E9%87%8F%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">（九）标量值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%EF%BC%89%E9%BB%98%E8%AE%A4%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-text">（十）默认字段值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Muduo%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%9A"><span class="toc-text">Muduo网络库：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AD%A3%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E6%8F%90%E5%87%BA%E6%9D%A5%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82%EF%BC%89%EF%BC%9A"><span class="toc-text">代码正式学习（这里主要提出来设计细节）：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#user-proto"><span class="toc-text">user.proto:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Krpcheader-proto"><span class="toc-text">Krpcheader.proto:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Krpcconfig%EF%BC%88%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%EF%BC%89"><span class="toc-text">Krpcconfig（配置加载模块）:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BC%98%E5%8C%96%E7%82%B9%EF%BC%9A"><span class="toc-text">可优化点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Krpclogger%EF%BC%88%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%89%EF%BC%9A"><span class="toc-text">Krpclogger（日志系统）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BC%98%E5%8C%96%E7%82%B9%EF%BC%9A-1"><span class="toc-text">可优化点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Krpcapplication%EF%BC%88%E6%A1%86%E6%9E%B6%E5%85%A5%E5%8F%A3%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%EF%BC%89%EF%BC%9A"><span class="toc-text">Krpcapplication（框架入口与系统管理）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BC%98%E5%8C%96%E7%82%B9%EF%BC%9A-2"><span class="toc-text">可优化点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KrpcChannel%EF%BC%9A"><span class="toc-text">KrpcChannel：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC%E5%A4%B4%E9%83%A8%E7%BB%84%E8%A3%85%EF%BC%9A"><span class="toc-text">RPC头部组装：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E7%8E%B0%EF%BC%9A"><span class="toc-text">客户端发现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BC%98%E5%8C%96%E7%82%B9%EF%BC%9A-3"><span class="toc-text">可优化点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Krpcprovider"><span class="toc-text">Krpcprovider:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NotifyService%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">NotifyService函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Run%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">Run函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnMessage-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">OnMessage()函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SendRpcResponse-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">SendRpcResponse()函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BC%98%E5%8C%96%E7%82%B9%EF%BC%9A-4"><span class="toc-text">可优化点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeperutil"><span class="toc-text">zookeeperutil:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Start%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">Start函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">Create函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetData%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">GetData函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BC%98%E5%8C%96%E7%82%B9%EF%BC%9A-5"><span class="toc-text">可优化点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KrpcControler%EF%BC%9A"><span class="toc-text">KrpcControler：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E4%B8%8E%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">项目设计思路与结构总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%EF%BC%9A"><span class="toc-text">分层架构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92%EF%BC%9A"><span class="toc-text">核心组件交互：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1"><span class="toc-text">关键流程设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 服务启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">2. RPC调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">服务端:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">3. 错误处理流程</span></a></li></ol></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
